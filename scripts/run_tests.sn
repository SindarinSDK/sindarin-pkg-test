// Sindarin Test Runner
//
// Cross-platform test runner for Sindarin projects.
// Works identically on Linux, macOS, and Windows.
//
// Usage:
//     run_tests [options] [test-dir]
//
// Options:
//     --compiler PATH   - Path to compiler (default: sn from PATH)
//     --timeout SEC     - Compile timeout in seconds (default: 60)
//     --run-timeout SEC - Run timeout in seconds (default: 30)
//     --verbose         - Show detailed output
//     --no-color        - Disable colored output
//     --parallel, -j N  - Run tests with N parallel workers (default: CPU count)

import "../../sindarin-pkg-sdk/src/os/os"
import "../../sindarin-pkg-sdk/src/os/process"
import "../../sindarin-pkg-sdk/src/os/env"
import "../../sindarin-pkg-sdk/src/io/path"
import "../../sindarin-pkg-sdk/src/io/directory"
import "../../sindarin-pkg-sdk/src/io/textfile"
import "../../sindarin-pkg-sdk/src/io/stdio"
import "../../sindarin-pkg-sdk/src/core/uuid"
import "../../sindarin-pkg-sdk/src/time/time"

// Maximum parallel workers
static var MAX_PARALLEL: int = 64

// ============================================================================
// String Utilities
// ============================================================================

// Workaround for compiler bug: strings from args[] are lost when struct is returned
// Using string interpolation forces a copy to the local arena
fn copyStr(s: str): str =>
    return $"{s}"

// Pad a string with spaces on the right to reach the desired width
fn padRight(s: str, width: int): str =>
    var result: str = s
    while result.length < width =>
        result = $"{result} "
    return result

// Pad a string with spaces on the left to reach the desired width
fn padLeft(s: str, width: int): str =>
    var result: str = s
    while result.length < width =>
        result = $" {result}"
    return result

// Column width for test name alignment
static var TEST_NAME_WIDTH: int = 40

// ============================================================================
// ANSI Colors
// ============================================================================

struct Colors =>
    red: str
    green: str
    yellow: str
    blue: str
    bold: str
    nc: str

// Global colors - initialized once at startup, never modified
// (Workaround for compiler bug: modifying static struct string fields causes corruption)
static var colors: Colors = Colors {
    red: "",
    green: "",
    yellow: "",
    blue: "",
    bold: "",
    nc: ""
}
static var colorsInitialized: bool = false

fn initColors(enabled: bool): void =>
    // Only initialize once to avoid the global struct modification bug
    if colorsInitialized =>
        return
    colorsInitialized = true

    if enabled =>
        // ESC character is ASCII 27
        var esc: char = 27 as char
        colors = Colors {
            red: $"{esc}[0;31m",
            green: $"{esc}[0;32m",
            yellow: $"{esc}[0;33m",
            blue: $"{esc}[0;34m",
            bold: $"{esc}[1m",
            nc: $"{esc}[0m"
        }
    // If not enabled, colors stay as empty strings (default)

// ============================================================================
// Diff Utilities
// ============================================================================

// Generate line-by-line diff details
fn generateDiffDetails(expected: str, actual: str, maxDiffs: int): str[] =>
    var details: str[] = {}
    var expectedLines: str[] = expected.splitLines()
    var actualLines: str[] = actual.splitLines()
    var maxLines: int = expectedLines.length
    if actualLines.length > maxLines =>
        maxLines = actualLines.length

    var diffCount: int = 0
    for i in 0..maxLines =>
        var exp: str = "<missing>"
        var act: str = "<missing>"
        if i < expectedLines.length =>
            exp = expectedLines[i]
        if i < actualLines.length =>
            act = actualLines[i]

        if exp != act =>
            if diffCount < maxDiffs =>
                var lineNum: int = i + 1
                details.push($"  line {lineNum}:")
                // Truncate long lines for readability
                if exp.length > 80 =>
                    exp = exp.substring(0, 80)
                if act.length > 80 =>
                    act = act.substring(0, 80)
                details.push($"    expected: {exp}")
                details.push($"    got:      {act}")
            diffCount = diffCount + 1

    if diffCount > maxDiffs =>
        var remaining: int = diffCount - maxDiffs
        details.push($"  ... and {remaining} more differences")

    if details.length == 0 && expected != actual =>
        details.push("Output differs (trailing whitespace/newlines)")

    return details

// ============================================================================
// Test Result
// ============================================================================

struct TestResult =>
    testName: str
    status: str      // "pass", "fail", "skip"
    reason: str
    details: str[]
    elapsedMs: long

// ============================================================================
// Test Configuration
// ============================================================================

struct TestConfig =>
    testDir: str
    pattern: str
    expectCompileFail: bool
    title: str

fn getTestConfig(testType: str): TestConfig =>
    if testType == "all" =>
        return TestConfig {
            testDir: "tests",
            pattern: "test_*.sn",
            expectCompileFail: false,
            title: "Tests"
        }
    // Default empty - will be overridden by custom directory if provided
    return TestConfig {
        testDir: "",
        pattern: "",
        expectCompileFail: false,
        title: ""
    }

// ============================================================================
// Command Execution with Timeout
// ============================================================================

struct CommandResult =>
    exitCode: int
    stdout: str
    stderr: str
    timedOut: bool

fn runWithTimeout(cmd: str, args: str[], timeoutSec: int): CommandResult =>
    // Use shell timeout command on Unix systems
    if OS.isUnix() && timeoutSec > 0 =>
        var timeoutArgs: str[] = {$"{timeoutSec}", cmd}
        for arg in args =>
            timeoutArgs.push(arg)
        var p: Process = Process.runArgs("timeout", timeoutArgs)
        // Exit code 124 means timeout killed the process
        return CommandResult {
            exitCode: p.exitCode(),
            stdout: p.stdout(),
            stderr: p.stderr(),
            timedOut: p.exitCode() == 124
        }
    else =>
        // No timeout support on Windows or if timeout is 0
        var p: Process = Process.runArgs(cmd, args)
        return CommandResult {
            exitCode: p.exitCode(),
            stdout: p.stdout(),
            stderr: p.stderr(),
            timedOut: false
        }

fn runShellWithTimeout(shellCmd: str, timeoutSec: int): CommandResult =>
    if OS.isUnix() && timeoutSec > 0 =>
        var p: Process = Process.runArgs("timeout", {$"{timeoutSec}", "sh", "-c", shellCmd})
        return CommandResult {
            exitCode: p.exitCode(),
            stdout: p.stdout(),
            stderr: p.stderr(),
            timedOut: p.exitCode() == 124
        }
    else =>
        var p: Process = Process.runArgs("sh", {"-c", shellCmd})
        return CommandResult {
            exitCode: p.exitCode(),
            stdout: p.stdout(),
            stderr: p.stderr(),
            timedOut: false
        }

// ============================================================================
// File Utilities
// ============================================================================

fn getExeExtension(): str =>
    if OS.isWindows() =>
        return ".exe"
    return ""

fn findTestFiles(dir: str, pattern: str): str[] =>
    var results: str[] = {}
    if !Path.isDirectory(dir) =>
        return results

    // Directory.listRecursive returns relative paths within the directory
    // We need to prepend the base directory to get full paths
    var files: str[] = Directory.listRecursive(dir)
    for relPath in files =>
        var fullPath: str = Path.join(dir, relPath)
        if !Path.isFile(fullPath) =>
            continue
        var filename: str = Path.filename(fullPath)
        // Simple pattern matching for *.sn and test_*.sn
        if pattern == "*.sn" =>
            if filename.endsWith(".sn") =>
                results.push(fullPath)
        else if pattern == "test_*.sn" =>
            if filename.startsWith("test_") && filename.endsWith(".sn") =>
                results.push(fullPath)
    return results

fn cleanupOrphanedTempDirs(): void =>
    var tempBase: str = "/tmp"
    if OS.isWindows() =>
        tempBase = Environment.getOr("TEMP", "C:\\Temp")

    if !Path.isDirectory(tempBase) =>
        return

    var entries: str[] = Directory.list(tempBase)
    var orphanCount: int = 0

    for entry in entries =>
        // Directory.list returns filenames only, not full paths
        if entry.startsWith("sn_test_") =>
            var fullPath: str = Path.join(tempBase, entry)
            if Path.isDirectory(fullPath) =>
                Directory.deleteRecursive(fullPath)
                orphanCount = orphanCount + 1

    if orphanCount > 0 =>
        print($"Cleaned up {orphanCount} orphaned test directories\n")

fn createTempDir(): str =>
    var tempBase: str = "/tmp"
    if OS.isWindows() =>
        tempBase = Environment.getOr("TEMP", "C:\\Temp")

    // Use UUID for unique temp directory name
    var id: UUID = UUID.create()
    var tempDir: str = Path.join(tempBase, $"sn_test_{id.toHex()}")
    Directory.create(tempDir)
    return tempDir

// ============================================================================
// Environment Configuration
// ============================================================================

fn setupTestEnvironment(): void =>
    // Set ASAN options to avoid leak detection issues
    if !Environment.has("ASAN_OPTIONS") =>
        Environment.set("ASAN_OPTIONS", "detect_leaks=0")

    // Setup library paths for runtime linking
    if OS.isWindows() =>
        // Windows: add vcpkg DLL directories to PATH
        var vcpkgBins: str[] = {
            Path.joinAll({"vcpkg", "installed", "x64-windows", "bin"}),
            Path.joinAll({"vcpkg", "installed", "x64-mingw-dynamic", "bin"}),
            Path.join3("bin", "deps", "lib")
        }
        var currentPath: str = Environment.getOr("PATH", "")
        for vcpkgBin in vcpkgBins =>
            if Path.isDirectory(vcpkgBin) =>
                var absPath: str = Path.absolute(vcpkgBin)
                if currentPath != "" =>
                    currentPath = $"{absPath};{currentPath}"
                else =>
                    currentPath = absPath
        if currentPath != "" =>
            Environment.set("PATH", currentPath)
    else =>
        // Linux/macOS: add library directories to LD_LIBRARY_PATH/DYLD_LIBRARY_PATH
        var libPaths: str[] = {
            Path.join3("bin", "deps", "lib"),
            Path.join3("vcpkg_installed", "x64-linux-dynamic", "lib"),
            Path.join3("vcpkg_installed", "arm64-osx", "lib"),
            Path.join3("vcpkg_installed", "x64-osx", "lib"),
            Path.joinAll({"vcpkg", "installed", "x64-linux-dynamic", "lib"}),
            Path.joinAll({"vcpkg", "installed", "arm64-osx", "lib"}),
            Path.joinAll({"vcpkg", "installed", "x64-osx", "lib"})
        }

        var existingPaths: str[] = {}
        for libPath in libPaths =>
            if Path.isDirectory(libPath) =>
                existingPaths.push(Path.absolute(libPath))

        if existingPaths.length > 0 =>
            var ldPathVar: str = "LD_LIBRARY_PATH"
            if OS.isMacOS() =>
                ldPathVar = "DYLD_LIBRARY_PATH"

            var currentPath: str = Environment.getOr(ldPathVar, "")
            var newPaths: str = existingPaths[0]
            for i in 1..existingPaths.length =>
                newPaths = $"{newPaths}:{existingPaths[i]}"

            if currentPath != "" =>
                Environment.set(ldPathVar, $"{newPaths}:{currentPath}")
            else =>
                Environment.set(ldPathVar, newPaths)

// ============================================================================
// Test Runner State
// ============================================================================

struct TestRunner =>
    compiler: str
    compileTimeout: int
    runTimeout: int
    verbose: bool
    parallel: int
    tempDir: str
    excludedTests: str[]

fn findCompiler(specifiedPath: str): str =>
    if specifiedPath != "" =>
        return Path.absolute(specifiedPath)

    var exeExt: str = getExeExtension()
    var candidate: str = $"bin/sn{exeExt}"

    if Path.isFile(candidate) =>
        return Path.absolute(candidate)

    // Check if sn is in PATH by running 'which sn' or 'where sn'
    var whichCmd: str = "which"
    if OS.isWindows() =>
        whichCmd = "where"

    var p: Process = Process.runArgs(whichCmd, {"sn"})
    var exitCode: int = p.exitCode()

    if exitCode == 0 =>
        // Take only the first line (where/which may return multiple paths)
        var output: str = p.stdout().trim()
        var lines: str[] = output.splitLines()
        if lines.length > 0 =>
            var snPath: str = lines[0].trim()
            if snPath != "" =>
                return snPath

    return ""

// ============================================================================
// Test Execution
// ============================================================================

fn isExcluded(testName: str, excluded: str[]): bool =>
    for ex in excluded =>
        if testName == ex =>
            return true
    return false

fn runErrorTest(runner: TestRunner, testFile: str, exeFile: str): TestResult =>
    var testName: str = Path.filename(testFile).replace(".sn", "")
    var expectedFile: str = testFile.replace(".sn", ".expected")

    if !Path.isFile(expectedFile) =>
        return TestResult {
            testName: testName,
            status: "skip",
            reason: "no .expected",
            details: {},
            elapsedMs: 0l
        }

    var startTime: Time = Time.now()

    // Try to compile (should fail)
    var result: CommandResult = runWithTimeout(runner.compiler, {testFile, "-o", exeFile, "-l", "1"}, runner.compileTimeout)

    var elapsed: long = Time.now().diff(startTime)

    if result.exitCode == 0 =>
        return TestResult {
            testName: testName,
            status: "fail",
            reason: "should not compile",
            details: {},
            elapsedMs: elapsed
        }

    // Check error message
    var expectedError: str = TextFile.readAll(expectedFile).splitLines()[0].trim()

    if result.stderr.contains(expectedError) =>
        return TestResult {
            testName: testName,
            status: "pass",
            reason: "",
            details: {},
            elapsedMs: elapsed
        }
    else =>
        return TestResult {
            testName: testName,
            status: "fail",
            reason: "wrong error",
            details: {$"Expected: {expectedError}", $"Got: {result.stderr}"},
            elapsedMs: elapsed
        }

fn runPositiveTest(runner: TestRunner, testFile: str, exeFile: str, testType: str): TestResult =>
    var testName: str = Path.filename(testFile).replace(".sn", "")
    var expectedFile: str = testFile.replace(".sn", ".expected")
    var panicFile: str = testFile.replace(".sn", ".panic")

    var hasExpected: bool = Path.isFile(expectedFile)
    var expectsPanic: bool = Path.isFile(panicFile)

    // For standard tests, require .expected file unless running in explore/all mode
    if !hasExpected && testType != "explore" && testType != "sdk" && testType != "all" =>
        return TestResult {
            testName: testName,
            status: "skip",
            reason: "no .expected",
            details: {},
            elapsedMs: 0l
        }

    var startTime: Time = Time.now()

    // Compile
    var compileArgs: str[] = {testFile, "-o", exeFile, "-l", "1", "-O0"}
    if OS.isUnix() =>
        compileArgs.push("-g")

    var compileResult: CommandResult = runWithTimeout(runner.compiler, compileArgs, runner.compileTimeout)

    if compileResult.exitCode != 0 =>
        var elapsed: long = Time.now().diff(startTime)
        return TestResult {
            testName: testName,
            status: "fail",
            reason: "compile error",
            details: compileResult.stderr.splitLines(),
            elapsedMs: elapsed
        }

    // Run
    var runTimeout: int = runner.runTimeout
    if testType == "integration" =>
        runTimeout = 5

    var runResult: CommandResult = runWithTimeout(exeFile, {}, runTimeout)
    var elapsed: long = Time.now().diff(startTime)

    // Check for timeout
    if runResult.timedOut =>
        return TestResult {
            testName: testName,
            status: "fail",
            reason: "timeout",
            details: {},
            elapsedMs: elapsed
        }

    // Check for expected panic
    if expectsPanic =>
        if runResult.exitCode == 0 =>
            return TestResult {
                testName: testName,
                status: "fail",
                reason: "expected panic",
                details: {},
                elapsedMs: elapsed
            }
    else =>
        if runResult.exitCode != 0 =>
            return TestResult {
                testName: testName,
                status: "fail",
                reason: $"exit code: {runResult.exitCode}",
                details: runResult.stdout.splitLines(),
                elapsedMs: elapsed
            }

    // Compare output if expected file exists
    if hasExpected =>
        var expectedOutput: str = TextFile.readAll(expectedFile)
        var actualOutput: str = runResult.stdout

        // Normalize line endings
        expectedOutput = expectedOutput.replace("\r\n", "\n")
        actualOutput = actualOutput.replace("\r\n", "\n")

        if actualOutput == expectedOutput =>
            return TestResult {
                testName: testName,
                status: "pass",
                reason: "",
                details: {},
                elapsedMs: elapsed
            }
        else =>
            // Generate detailed line-by-line diff
            var diffDetails: str[] = generateDiffDetails(expectedOutput, actualOutput, 10)
            return TestResult {
                testName: testName,
                status: "fail",
                reason: "output mismatch",
                details: diffDetails,
                elapsedMs: elapsed
            }

    return TestResult {
        testName: testName,
        status: "pass",
        reason: "",
        details: {},
        elapsedMs: elapsed
    }

fn runSingleTest(runner: TestRunner, testFile: str, testType: str, testIndex: int): TestResult =>
    var testName: str = Path.filename(testFile).replace(".sn", "")

    if isExcluded(testName, runner.excludedTests) =>
        return TestResult {
            testName: testName,
            status: "skip",
            reason: "excluded",
            details: {},
            elapsedMs: 0l
        }

    var exeExt: str = getExeExtension()
    var exeFile: str = Path.join(runner.tempDir, $"test_{testIndex}_{testName}{exeExt}")

    var config: TestConfig = getTestConfig(testType)

    if config.expectCompileFail =>
        return runErrorTest(runner, testFile, exeFile)
    else =>
        return runPositiveTest(runner, testFile, exeFile, testType)

// ============================================================================
// Threaded Test Execution
// ============================================================================

// Thread-safe counters
sync var passedCount: int = 0
sync var failedCount: int = 0
sync var skippedCount: int = 0
sync var completedCount: int = 0

fn recordResult(result: TestResult): void =>
    if result.status == "pass" =>
        passedCount++
    else if result.status == "fail" =>
        failedCount++
    else =>
        skippedCount++
    completedCount++

// Print live progress counter (overwrites current line)
fn printProgress(current: int, total: int): void =>
    // Use carriage return to overwrite the line
    var cr: char = 13 as char
    print($"{cr}  Running tests... [{current}/{total}]")
    Stdout.flush()

// Clear the progress line
fn clearProgress(): void =>
    var cr: char = 13 as char
    print($"{cr}                                        {cr}")

fn printTestResult(result: TestResult, verbose: bool): void =>
    var timeStr: str = ""
    if result.elapsedMs > 0l =>
        if result.elapsedMs >= 1000l =>
            var secs: long = result.elapsedMs / 1000l
            var ms: long = result.elapsedMs % 1000l
            timeStr = $" ({secs}.{ms}s)"
        else =>
            timeStr = $" ({result.elapsedMs}ms)"

    // Pad the test name for alignment
    var paddedName: str = padRight(result.testName, TEST_NAME_WIDTH)

    if result.status == "pass" =>
        print($"  {paddedName} {colors.green}PASS{colors.nc}{timeStr}\n")
    else if result.status == "skip" =>
        print($"  {paddedName} {colors.yellow}SKIP{colors.nc} ({result.reason})\n")
    else =>
        print($"  {paddedName} {colors.red}FAIL{colors.nc} ({result.reason}){timeStr}\n")
        if verbose =>
            for detail in result.details =>
                print($"    {detail}\n")

// ============================================================================
// Test Suite Runners
// ============================================================================

fn runSnTestsWithDir(runner: TestRunner, testType: str, customDir: str): bool =>
    var config: TestConfig = getTestConfig(testType)

    // Override testDir if custom directory is provided
    if customDir != "" =>
        // Create a new config to avoid struct field modification issues
        var newPattern: str = config.pattern
        if newPattern == "" =>
            newPattern = "test_*.sn"
        var newTitle: str = config.title
        if newTitle == "" =>
            newTitle = "Custom Tests"
        config = TestConfig {
            testDir: customDir,
            pattern: newPattern,
            expectCompileFail: config.expectCompileFail,
            title: newTitle
        }

    if config.testDir == "" =>
        print($"Unknown test type: {testType}\n")
        return false

    print($"\n{colors.bold}{config.title}{colors.nc}\n")
    print("============================================================\n")

    var testFiles: str[] = findTestFiles(config.testDir, config.pattern)

    if testFiles.length == 0 =>
        print($"No test files found in: {config.testDir}\n")
        return true

    // Reset counters
    passedCount = 0
    failedCount = 0
    skippedCount = 0
    completedCount = 0

    var startTime: Time = Time.now()

    // Cap parallel workers at MAX_PARALLEL
    var parallelWorkers: int = runner.parallel
    if parallelWorkers > MAX_PARALLEL =>
        parallelWorkers = MAX_PARALLEL
    if parallelWorkers < 1 =>
        parallelWorkers = 1

    // Parallel execution using array-based thread spawning
    if parallelWorkers > 1 =>
        var batchStart: int = 0
        var allResults: TestResult[] = {}

        // Show initial progress
        printProgress(0, testFiles.length)

        while batchStart < testFiles.length =>
            var batchEnd: int = batchStart + parallelWorkers
            if batchEnd > testFiles.length =>
                batchEnd = testFiles.length

            // Spawn batch of threads into array
            var batch: TestResult[] = {}
            for i in batchStart..batchEnd =>
                batch.push(&runSingleTest(runner, testFiles[i], testType, i))

            // Sync all threads in batch
            batch!

            // Collect results
            for i in 0..batch.length =>
                allResults.push(batch[i])
                printProgress(allResults.length, testFiles.length)

            batchStart = batchEnd

        // Clear progress line and print all results
        clearProgress()
        for result in allResults =>
            recordResult(result)
            printTestResult(result, runner.verbose)
    else =>
        // Sequential execution (parallel = 1)
        var seqResults: TestResult[] = {}
        var idx: int = 0
        printProgress(0, testFiles.length)
        for testFile in testFiles =>
            var result: TestResult = runSingleTest(runner, testFile, testType, idx)
            seqResults.push(result)
            idx = idx + 1
            printProgress(idx, testFiles.length)
        // Clear progress and print results
        clearProgress()
        for result in seqResults =>
            recordResult(result)
            printTestResult(result, runner.verbose)

    var elapsed: long = Time.now().diff(startTime)

    print("\n------------------------------------------------------------\n")
    print($"Results: {colors.green}{passedCount} passed{colors.nc}, ")
    print($"{colors.red}{failedCount} failed{colors.nc}, ")
    print($"{colors.yellow}{skippedCount} skipped{colors.nc}  ({elapsed}ms)\n")

    return failedCount == 0

fn runSnTests(runner: TestRunner, testType: str): bool =>
    return runSnTestsWithDir(runner, testType, "")

// ============================================================================
// Argument Parsing
// ============================================================================

struct Args =>
    testType: str = ""
    testDir: str = ""
    compiler: str = ""
    timeout: int = 60
    runTimeout: int = 30
    verbose: bool = false
    noColor: bool = false
    parallel: int = 0  // 0 means auto-detect (use CPU count)
    excludedTests: str[]
    showHelp: bool = false

fn parseArgs(args: str[]): Args =>
    var result: Args = Args {
        excludedTests: {}
    }
    // Start at 1 to skip program name (args[0])
    var i: int = 1

    while i < args.length =>
        var arg: str = args[i]

        if arg == "--help" || arg == "-h" =>
            result.showHelp = true
        else if arg == "--compiler" || arg == "-c" =>
            if i + 1 < args.length =>
                i = i + 1
                // Use copyStr to work around compiler bug with args[] strings in returned structs
                result.compiler = copyStr(args[i])
        else if arg == "--timeout" =>
            if i + 1 < args.length =>
                i = i + 1
                result.timeout = args[i].toInt()
        else if arg == "--run-timeout" =>
            if i + 1 < args.length =>
                i = i + 1
                result.runTimeout = args[i].toInt()
        else if arg == "--verbose" || arg == "-v" =>
            result.verbose = true
        else if arg == "--no-color" =>
            result.noColor = true
        else if arg == "--parallel" || arg == "-j" =>
            if i + 1 < args.length =>
                i = i + 1
                result.parallel = args[i].toInt()
        else if arg == "--exclude" =>
            if i + 1 < args.length =>
                i = i + 1
                var excluded: str[] = args[i].split(",")
                for ex in excluded =>
                    // Use copyStr for excluded test names too
                    result.excludedTests.push(copyStr(ex.trim()))
        else if !arg.startsWith("-") =>
            // Use copyStr to work around compiler bug with args[] strings in returned structs
            // First positional arg is test type, second is optional test directory
            if result.testType == "" =>
                result.testType = copyStr(arg)
            else if result.testDir == "" =>
                result.testDir = copyStr(arg)

        i = i + 1

    return result

fn printUsage(): void =>
    print("Sindarin Test Runner\n\n")
    print("Usage: run_tests [options] [test-dir]\n\n")
    print("Arguments:\n")
    print("  test-dir           Test directory (default: tests/)\n\n")
    print("Options:\n")
    print("  --compiler PATH    Path to Sindarin compiler (default: sn from PATH)\n")
    print("  --timeout SEC      Compile timeout in seconds (default: 60)\n")
    print("  --run-timeout SEC  Run timeout in seconds (default: 30)\n")
    print("  --exclude TESTS    Comma-separated list of tests to exclude\n")
    print("  --verbose, -v      Show detailed output\n")
    print("  --no-color         Disable colored output\n")
    print("  --parallel, -j N   Run tests with N parallel workers (default: CPU count)\n")
    print("  --help, -h         Show this help message\n")

// ============================================================================
// Main
// ============================================================================

fn main(args: str[]): int =>
    var parsedArgs: Args = parseArgs(args)

    // Default test type to "all" if not specified
    if parsedArgs.testType == "" =>
        parsedArgs.testType = "all"

    // Default parallel workers to CPU count if not specified
    if parsedArgs.parallel == 0 =>
        parsedArgs.parallel = OS.cpuCount()

    if parsedArgs.showHelp =>
        printUsage()
        return 0

    // Handle colors - initialize once with the correct setting
    initColors(!parsedArgs.noColor)

    // Setup test environment (ASAN options, library paths)
    setupTestEnvironment()

    // Clean up orphaned temp directories
    cleanupOrphanedTempDirs()

    // Find compiler
    var compiler: str = findCompiler(parsedArgs.compiler)
    if compiler == "" =>
        print($"{colors.red}Error:{colors.nc} Could not find compiler. Specify with --compiler\n")
        return 1

    // Check for excluded tests from environment
    if Environment.has("SN_EXCLUDE_TESTS") =>
        var envExclude: str = Environment.get("SN_EXCLUDE_TESTS")
        var excluded: str[] = envExclude.splitWhitespace()
        for ex in excluded =>
            parsedArgs.excludedTests.push(ex)

    // Create temp directory
    var tempDir: str = createTempDir()

    // Print info
    print($"Compiler: {compiler}\n")
    print($"Platform: {OS.name()}\n")
    if parsedArgs.parallel > 1 =>
        print($"Parallel: {parsedArgs.parallel} workers\n")

    // Create runner
    var runner: TestRunner = TestRunner {
        compiler: compiler,
        compileTimeout: parsedArgs.timeout,
        runTimeout: parsedArgs.runTimeout,
        verbose: parsedArgs.verbose,
        parallel: parsedArgs.parallel,
        tempDir: tempDir,
        excludedTests: parsedArgs.excludedTests
    }

    var allPassed: bool = true

    // Run tests - use custom directory if specified, otherwise use default tests/ directory
    if parsedArgs.testDir != "" =>
        allPassed = runSnTestsWithDir(runner, parsedArgs.testType, parsedArgs.testDir)
    else =>
        allPassed = runSnTests(runner, parsedArgs.testType)

    // Cleanup temp directory
    Directory.deleteRecursive(tempDir)

    print("\n")
    if allPassed =>
        print($"{colors.green}{colors.bold}All tests passed!{colors.nc}\n")
        return 0
    else =>
        print($"{colors.red}{colors.bold}Some tests failed!{colors.nc}\n")
        return 1
